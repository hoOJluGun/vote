import Foundation
import AsyncHTTPClient
import Logging
import NIO
import Collections

// MARK: - Monitoring Service

public class MonitoringService: ObservableObject {
    // MARK: - Published Properties
    
    @Published public var services: [Service] = []
    @Published public var isRunning = false
    @Published public var lastCheck: Date = Date()
    @Published public var overallStatus: MonitoringStatus = .unknown
    
    // MARK: - Private Properties
    
    private let logger = Logger(label: "MonitoringService")
    private let httpClient: HTTPClient
    private var monitoringTask: Task<Void, Never>?
    private var checkInterval: TimeInterval = 30 // —Å–µ–∫—É–Ω–¥—ã
    
    // MARK: - Initialization
    
    public init(httpClient: HTTPClient) {
        self.httpClient = httpClient
        logger.info("üîç MonitoringService –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    }
    
    deinit {
        Task {
            await shutdown()
        }
    }
    
    // MARK: - Public Methods
    
    public func initialize() async {
        logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞")
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–æ–≤
        await loadServicesConfiguration()
        
        // –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        startMonitoring()
        
        isRunning = true
        logger.info("‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω")
    }
    
    public func shutdown() async {
        logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞")
        
        isRunning = false
        monitoringTask?.cancel()
        
        logger.info("‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    }
    
    public func checkAllServices() async -> MonitoringStatus {
        logger.debug("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤")
        
        var healthyServices = 0
        var totalServices = services.count
        var criticalFailures = 0
        var warnings = 0
        
        await withTaskGroup(of: ServiceCheckResult.self) { group in
            for service in services {
                group.addTask {
                    await self.checkService(service)
                }
            }
            
            for await result in group {
                switch result.status {
                case .healthy:
                    healthyServices += 1
                case .warning:
                    warnings += 1
                case .critical:
                    criticalFailures += 1
                case .unknown:
                    break
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä–≤–∏—Å–æ–≤
        await updateServicesStatus()
        
        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–±—â–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
        let status = MonitoringStatus(
            healthyServices: healthyServices,
            totalServices: totalServices,
            criticalFailures: criticalFailures,
            warnings: warnings,
            lastCheck: Date()
        )
        
        await MainActor.run {
            self.overallStatus = status
            self.lastCheck = Date()
        }
        
        logger.debug("üìä –°—Ç–∞—Ç—É—Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: \(status)")
        return status
    }
    
    public func checkService(_ service: Service) async -> ServiceCheckResult {
        logger.debug("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä–≤–∏—Å–∞: \(service.name)")
        
        do {
            let result = try await performServiceCheck(service)
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä–≤–∏—Å–∞
            await updateServiceStatus(service, result: result)
            
            return result
        } catch {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Ä–≤–∏—Å–∞ \(service.name): \(error)")
            
            let result = ServiceCheckResult(
                serviceName: service.name,
                status: .critical,
                responseTime: nil,
                error: error.localizedDescription,
                timestamp: Date()
            )
            
            await updateServiceStatus(service, result: result)
            return result
        }
    }
    
    public func addService(_ service: Service) async {
        await MainActor.run {
            services.append(service)
        }
        logger.info("‚ûï –î–æ–±–∞–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: \(service.name)")
    }
    
    public func removeService(_ serviceName: String) async {
        await MainActor.run {
            services.removeAll { $0.name == serviceName }
        }
        logger.info("‚ûñ –£–¥–∞–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: \(serviceName)")
    }
    
    public func createNewMonitoring() async {
        logger.info("üìä –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞")
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –±–∞–∑–æ–≤—ã–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏
        let defaultServices = [
            Service(
                name: "Web Frontend",
                type: .http,
                url: "https://your-domain.com/health",
                timeout: 10,
                checkInterval: 30
            ),
            Service(
                name: "Telegram Bot",
                type: .http,
                url: "https://bot.your-domain.com/health",
                timeout: 10,
                checkInterval: 30
            ),
            Service(
                name: "API Backend",
                type: .http,
                url: "https://api.your-domain.com/health",
                timeout: 10,
                checkInterval: 30
            ),
            Service(
                name: "Database",
                type: .custom,
                url: nil,
                timeout: 5,
                checkInterval: 60
            )
        ]
        
        for service in defaultServices {
            await addService(service)
        }
    }
    
    // MARK: - Private Methods
    
    private func startMonitoring() {
        monitoringTask = Task {
            while !Task.isCancelled {
                let _ = await checkAllServices()
                try? await Task.sleep(nanoseconds: UInt64(checkInterval * 1_000_000_000))
            }
        }
    }
    
    private func loadServicesConfiguration() async {
        // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞ –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
        // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        
        // –í—Ä–µ–º–µ–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        let defaultServices = [
            Service(
                name: "System Health",
                type: .system,
                url: nil,
                timeout: 5,
                checkInterval: 60
            )
        ]
        
        for service in defaultServices {
            await addService(service)
        }
    }
    
    private func performServiceCheck(_ service: Service) async throws -> ServiceCheckResult {
        let startTime = Date()
        
        switch service.type {
        case .http:
            return try await checkHTTPService(service, startTime: startTime)
        case .tcp:
            return try await checkTCPService(service, startTime: startTime)
        case .custom:
            return try await checkCustomService(service, startTime: startTime)
        case .system:
            return try await checkSystemService(service, startTime: startTime)
        }
    }
    
    private func checkHTTPService(_ service: Service, startTime: Date) async throws -> ServiceCheckResult {
        guard let url = service.url else {
            throw MonitoringError.invalidURL
        }
        
        var request = HTTPClientRequest(url: url)
        request.method = .GET
        request.timeout = .seconds(Int64(service.timeout))
        
        let response = try await httpClient.execute(request, timeout: .seconds(Int64(service.timeout)))
        let responseTime = Date().timeIntervalSince(startTime)
        
        let status: ServiceStatus
        if response.status.code >= 200 && response.status.code < 300 {
            status = .healthy
        } else if response.status.code >= 400 && response.status.code < 500 {
            status = .warning
        } else {
            status = .critical
        }
        
        return ServiceCheckResult(
            serviceName: service.name,
            status: status,
            responseTime: responseTime,
            error: nil,
            timestamp: Date()
        )
    }
    
    private func checkTCPService(_ service: Service, startTime: Date) async throws -> ServiceCheckResult {
        guard let url = service.url else {
            throw MonitoringError.invalidURL
        }
        
        // TCP –ø—Ä–æ–≤–µ—Ä–∫–∞
        let responseTime = Date().timeIntervalSince(startTime)
        
        return ServiceCheckResult(
            serviceName: service.name,
            status: .healthy,
            responseTime: responseTime,
            error: nil,
            timestamp: Date()
        )
    }
    
    private func checkCustomService(_ service: Service, startTime: Date) async throws -> ServiceCheckResult {
        // –ö–∞—Å—Ç–æ–º–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö)
        let responseTime = Date().timeIntervalSince(startTime)
        
        // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –∫–∞—Å—Ç–æ–º–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
        let isHealthy = await performCustomCheck(service)
        
        return ServiceCheckResult(
            serviceName: service.name,
            status: isHealthy ? .healthy : .critical,
            responseTime: responseTime,
            error: nil,
            timestamp: Date()
        )
    }
    
    private func checkSystemService(_ service: Service, startTime: Date) async throws -> ServiceCheckResult {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
        let responseTime = Date().timeIntervalSince(startTime)
        
        let systemHealth = await checkSystemHealth()
        
        return ServiceCheckResult(
            serviceName: service.name,
            status: systemHealth.isHealthy ? .healthy : (systemHealth.hasWarnings ? .warning : .critical),
            responseTime: responseTime,
            error: systemHealth.error,
            timestamp: Date()
        )
    }
    
    private func performCustomCheck(_ service: Service) async -> Bool {
        // –ö–∞—Å—Ç–æ–º–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏
        switch service.name.lowercased() {
        case "database":
            return await checkDatabaseHealth()
        case "file_system":
            return await checkFileSystemHealth()
        case "disk_space":
            return await checkDiskSpaceHealth()
        default:
            return true
        }
    }
    
    private func checkDatabaseHealth() async -> Bool {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ë–î
        return true
    }
    
    private func checkFileSystemHealth() async -> Bool {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
        let criticalPaths = [
            "./data",
            "./backups",
            "./security"
        ]
        
        for path in criticalPaths {
            if !FileManager.default.fileExists(atPath: path) {
                return false
            }
        }
        
        return true
    }
    
    private func checkDiskSpaceHealth() async -> Bool {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –Ω–∞ –¥–∏—Å–∫–µ
        do {
            let attributes = try FileManager.default.attributesOfFileSystem(forPath: "/")
            if let freeSize = attributes[.systemFreeSize] as? NSNumber {
                let freeGB = freeSize.doubleValue / (1024 * 1024 * 1024)
                return freeGB > 1.0 // –ú–∏–Ω–∏–º—É–º 1GB —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞
            }
        } catch {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–∏—Å–∫–∞: \(error)")
        }
        
        return false
    }
    
    private func checkSystemHealth() async -> SystemHealth {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
        let processInfo = ProcessInfo.processInfo
        let memoryUsage = processInfo.physicalMemory
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏
        let memoryPressure = processInfo.thermalState
        let hasWarnings = memoryPressure == .serious || memoryPressure == .critical
        
        return SystemHealth(
            isHealthy: !hasWarnings,
            hasWarnings: hasWarnings,
            error: hasWarnings ? "–í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤" : nil
        )
    }
    
    private func updateServiceStatus(_ service: Service, result: ServiceCheckResult) async {
        await MainActor.run {
            if let index = services.firstIndex(where: { $0.name == service.name }) {
                services[index].lastCheck = result.timestamp
                services[index].lastStatus = result.status
                services[index].lastResponseTime = result.responseTime
                services[index].lastError = result.error
            }
        }
    }
    
    private func updateServicesStatus() async {
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—â–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä–≤–∏—Å–æ–≤
        await MainActor.run {
            // –õ–æ–≥–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
        }
    }
}

// MARK: - Supporting Types

public struct Service: Identifiable {
    public let id = UUID()
    public let name: String
    public let type: ServiceType
    public let url: String?
    public let timeout: TimeInterval
    public let checkInterval: TimeInterval
    
    // –°—Ç–∞—Ç—É—Å
    public var lastCheck: Date = Date()
    public var lastStatus: ServiceStatus = .unknown
    public var lastResponseTime: TimeInterval?
    public var lastError: String?
    
    public var isHealthy: Bool {
        lastStatus == .healthy
    }
    
    public var status: String {
        switch lastStatus {
        case .healthy: return "–†–∞–±–æ—Ç–∞–µ—Ç"
        case .warning: return "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ"
        case .critical: return "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π"
        case .unknown: return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        }
    }
    
    public init(name: String, type: ServiceType, url: String?, timeout: TimeInterval, checkInterval: TimeInterval) {
        self.name = name
        self.type = type
        self.url = url
        self.timeout = timeout
        self.checkInterval = checkInterval
    }
}

public enum ServiceType: String, CaseIterable {
    case http = "HTTP"
    case tcp = "TCP"
    case custom = "Custom"
    case system = "System"
}

public enum ServiceStatus: String, CaseIterable {
    case healthy = "healthy"
    case warning = "warning"
    case critical = "critical"
    case unknown = "unknown"
}

public struct ServiceCheckResult {
    public let serviceName: String
    public let status: ServiceStatus
    public let responseTime: TimeInterval?
    public let error: String?
    public let timestamp: Date
}

public struct MonitoringStatus {
    public let healthyServices: Int
    public let totalServices: Int
    public let criticalFailures: Int
    public let warnings: Int
    public let lastCheck: Date
    
    public var hasCriticalFailures: Bool {
        criticalFailures > 0
    }
    
    public var hasWarnings: Bool {
        warnings > 0
    }
    
    public var healthPercentage: Double {
        guard totalServices > 0 else { return 0 }
        return Double(healthyServices) / Double(totalServices) * 100
    }
}

public struct SystemHealth {
    public let isHealthy: Bool
    public let hasWarnings: Bool
    public let error: String?
}

public enum MonitoringError: Error {
    case invalidURL
    case timeout
    case networkError
    case serviceUnavailable
}
